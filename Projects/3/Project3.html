<html>
  <head>
    <title>CIS 505/705 Assignment #3</title>
  </head>

  <body>
    <h1>CIS 505/705, (Introduction to) Programming Languages, Fall 2018.</h1>
<h2>Assignment #3 (25 points). Due on Monday, October 29, 2018, 8am</h2>

Use <em><a href="http://docs.racket-lang.org/guide/">Racket</a></em> to write an interpreter for the higher-order functional language described in the text below.
<p>
The main techniques for doing so 
<ul>
<li>
are mentioned in the slides <tt>HigherOrderFunctionsInterpret</tt> (uploaded
on Canvas), and 
<li>
are also mentioned in
<a href="http://cs.brown.edu/courses/cs173/2012/book/higher-order-functions.html">Chapter 7</a> of the textbook.
</ul>
The expected benefits are that you will understand
<ul>
<li>
the use of <em>closures</em> to implement functions with static scope
<li>
how to implement dynamic checks to ensure a safe run-time system
<li>
how to provide domain-specific features.
</ul>
<em>Possible</em> benefits are that you will understand
<ul>
<li>
challenges to implementing recursion.
</ul>

<h3>Language Syntax</h3>
<em>Expressions</em> are given by the syntax
<pre>
exp ::= id
     |  num
     |  "fn" id exp
     |  "app" exp1 exp2
     |  "let" id exp1 exp2
     |  "if" exp1 exp2 exp3
     |  op exp1 exp2 
     |  "tuple" id1 id2
     |  "select1" id1 exp0
     |  "select2" id2 exp0

 op ::= "+" 
     |  "-" 
     |  "*" 
</pre>
That is, an expression can be 
<ul>
<li>
an identifier (a sequence of one or more
letters or digits that starts with a letter and that is not a keyword)
<li>
 a number (a sequence of one or more digits)
<li>
an anonymous function definition
<li> a function application
<li> a let binding (much as in SML)
<li> a conditional
<li> an application 
(written in prefix notation) of an operator.
</ul>
The constructs <tt>tuple</tt> and <tt>select1/2</tt>
will be discussed later.

<h3>Language Semantics</h3>
Programs manipulate 3 kinds of <em>values</em>:
<ul>
<li>
integers
<li>
function closures
<li>
tables (to be introduced and discussed later).
</ul>
The final value of a program must be an integer or a table
(not a closure).
<p>
For conditionals, a value is considered true iff it is 
a positive integer.
<p>
We assume <em>static scope</em> so that an expression can use only
<ul>
<li>
formal parameters of surrounding function definitions
<li>
identifiers bound by surrounding <tt>let</tt> definitions
</ul>
Observe that this excludes recursive definitions.
<p>
We assume a <em>call-by-value</em> semantics:
<ul>
<li>
in a function application, the actual parameter is evaluated
before the function body is evaluated;
<li>
in an expression <tt>let x e1 e2</tt>, the <tt>value</tt> of <tt>e1</tt>
will be bound to <tt>x</tt> before <tt>e2</tt> is evaluated.
</ul>
<p>
<h4>Examples</h3>
<pre>
let plus fn x fn y + x y 
let plusfive app plus 5 
app plusfive 8
</pre>
should return 13.
<p>
<pre>
let twice fn f fn x app f app f x
let multseven fn x * 7 x 
app app twice multseven 2
</pre>
should return 98.
<p>
<h4>Recursion</h4>
The natural attempt
<pre>
let fac fn n 
  if n * n 
   app fac - n 1 
   1 
app fac 6
</pre>
should cause a complaint about <tt>fac</tt> being undefined.
But the below piece of magic
<!-- Z = λf.(λx.f (λv.((x x) v))) (λx.f (λv.((x x) v))) -->
<pre>
let Z fn f app fn x app f fn v app app x x v fn x app f fn v app app x x v
let Fac fn f fn n 
   if n * n app f - n 1 
   1
app app Z Fac 6
</pre>
should return 720. 
<p>
<h4>Tables</h4>
A table is a set of pairs of symbols, where 
<ul>
<li>
a symbol (just like an identifier)
starts with a letter, followed by zero or more letters and/or digits
<li>
a set is represented as a list.
</ul>
We shall now introduce the various operations on tables.
<ul>
<li>
The operator <tt>tuple</tt> constructs a singleton set:
<pre>
tuple France Paris
</pre>
should return a list <tt>'(("France" . "Paris"))</tt>
containing only the pair (France,Paris).
<p>
<li>
We <em>overload</em>
the operator &quot;+&quot; 
so that an an expression <tt>+ e1 e2</tt>,
where <tt>e1</tt> evaluates to a table <tt>t1</tt> and
<tt>e2</tt> evaluates to a table <tt>t2</tt>,
returns a table <tt>t</tt>
whose pairs are the entries in <tt>t1</tt> followed
by the entries in <tt>t2</tt>
(you may remove duplicates but are not required to).
For example,
<pre>
+ tuple France Paris 
  tuple Spain Madrid
</pre>
should return a list containing the pair (France,Paris) and
the pair (Spain, Madrid).
<p>
<li>
We also overload 
the operator &quot;-&quot; so that when applied to two tables,
it returns the pairs in the first that are not present in the second.
For example,
<pre>
let two + tuple France Paris 
          tuple Spain Madrid
let one tuple France Paris
- two one
</pre>
should return a list containing only the pair (Spain,Madrid).
<p>
<li>
We use the <tt>select</tt> operators to filter pairs:
if <tt>s1</tt> is a string, and <tt>e0</tt> evaluates to a table <tt>t0</tt>,
then <tt>select1 s1 e0</tt> returns the pairs in <tt>t0</tt> whose
first component contain <tt>s</tt> as a <em>prefix</em>. For example,
<pre>
let table + + tuple France Paris tuple Spain Madrid tuple Finland Helsinki
select1 F table
</pre>
should return the pairs (France,Paris) and (Finland,Helsinki).
<p>
Similarly, <tt>select2</tt> filters based on the <em>second</em>
component.
<p>
<li>
Finally, we overload
the operator &quot;*&quot;
so as to represent the
<em>join</em> operator, much as known from
<a href="https://en.wikipedia.org/wiki/Relational_algebra#Natural_join">relational algebra</a> except that (so as to keep tuples binary) we throw away
the components being &quot;joined&quot;.
For example,
<pre>
let table1 + + + tuple a1 b1 tuple a2 b2 tuple a3 b2 tuple a2 b3
let table2 + + + tuple b3 c1 tuple b2 c3 tuple b2 c4 tuple b4 c2
* table1 table2
</pre>
should return the tuples (the order does not matter)
(a2,c3), (a2,c4), (a3,c3), (a3,c4), (a2,c1).
<p>
</ul>
For a larger example, consider the program
<pre>
let countries 
      +++ tuple Asia Japan 
          tuple Asia China
        + tuple Europe UK 
          tuple America Canada
       ++ tuple America US
          tuple Europe Italy
        + tuple Africa Kenya
          tuple Europe France
let capitals
      +++ tuple Japan Tokyo 
          tuple France Paris
        + tuple Italy Rome 
          tuple UK London
       ++ tuple Canada Ottawa 
          tuple US DC
        + tuple Kenya Nairobi
          tuple China Beijing
let join * countries capitals
 - select1 A join 
   tuple America Ottawa
</pre>
which associates the continents with capitals on that continent,
except we only consider continents that start with the letter A,
and do not consider Ottawa. 
<p>
Hence, the above query should return the pairs
(Asia,Tokyo), (Asia,Beijing), 
(America,DC), (Africa,Nairobi).
<p>
<h3>Functionality of Interpreter</h3>
You must write a Racket program,
using the skeleton provided (which includes a parser)
that evaluates programs in the given language.
<p>
Your program should be such that if you put it in a file <tt>FunFun.rkt</tt>,
in the top area of DrRacket type
<pre>
#lang racket
(require "FunFun.rkt")
</pre>
 and in the bottom area type
<pre>
  (run "&lt;text of program&gt;")
</pre>
then the value of that program will be output. 
<p>

<h4>Error Messages</h3>
Your interpreter should give suitable error messages, for example if
  <ul>
    <li>
      an identifier is used that is not in the current (static) scope
    <li>
      an operand is a function
    <li> 
      an integer is applied to some argument
    </ul>
<p>
As long as your interpreter reports a given error, you are <em>not</em> 
required to ensure that it then terminates properly without further error messages.

<p>
<h3>Submission</h3>
You must do this exercise on your own.
<p>
Submit to Canvas 
<em>one</em> file which should contain your Racket interpreter.
<p>
Do <em>not</em> 
expect the instructor or the TAs to answer any questions after Friday, October 26, at 4pm.
<p>
<b>Important</b>:
It is certainly OK to discuss the assignment with 
the instructor, TAs, or your fellow students, 
but all the coding must be typed by you,
and all the concepts in the coding must be stored in your head so that 
you can reproduce them on demand.
    <hr>
    <address>Torben Amtoft</address>
  </body>
</html>

